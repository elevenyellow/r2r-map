<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <title>Three.js 101</title>
  <style>
    body { margin: 0; overflow: hidden; } 
    canvas { width: 100%; height: 100% }
  </style>
</head>
<body>
  <canvas id="canvas" />
</body>
<script src="js/d3-selection.v1.min.js"></script>
<script src="js/d3-dispatch.v1.min.js"></script>
<script src="js/d3-transition.v1.min.js"></script>
<script src="js/d3-drag.v1.min.js"></script>
<script src="js/d3-zoom.v1.min.js"></script>
<script src="js/three.js"></script>
<script>
    var angleV = 40 // vertical angle
    var angleH = 45 // horizontal angle
    var radius = 80 // or distance
    var fov = 10 // the lower the better to respect the proportions (to be orthographic)
    var width = window.innerWidth
    var height = window.innerHeight
    var camera = new THREE.PerspectiveCamera(
        fov,
        width / height, // aspect
        10, // near
        500 // far
    )
    var scene = new THREE.Scene()
    var canvas = document.getElementById('canvas')
    var renderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
        canvas: canvas
    })
    renderer.setClearColor('#000000')
    renderer.setPixelRatio(window.devicePixelRatio)
    renderer.setSize(width, height)
    function animate(time) {
        renderer.render(scene, camera)
        requestAnimationFrame(animate)
    }
    animate()
    window.addEventListener('resize', function() {
        width = window.innerWidth
        height = window.innerHeight
        updateCameraPosition(d3_transform)
        renderer.setSize(width, height)
        camera.aspect = width / height
        camera.updateProjectionMatrix()
    })
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    // d3
    var d3_transform
    var zoom = d3
        .zoom()
        .scaleExtent([
            getScaleFromRadius(radius * 2),
            getScaleFromRadius(radius / 1.5)
        ])
        .on('zoom', function() {
            d3_transform = d3.event.transform
            return updateCameraPosition(d3_transform)
        })
    var view = d3.select(renderer.domElement)
    view.call(zoom)
    var initial_scale = getScaleFromRadius(radius)
    var initial_transform = d3.zoomIdentity
        .translate(width / 2, height / 2)
        .scale(initial_scale)
    zoom.transform(view, initial_transform)
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    // elements

    // sprites
// http://stemkoski.github.io/Three.js/Sprites.html
var textureLoader = new THREE.TextureLoader();
var spriteMap = new textureLoader.load( "assets/obj/tree.png" );
var spriteMap2 = new textureLoader.load( "assets/obj/tree2.png" );
var spriteMap3 = new textureLoader.load( "assets/obj/tree3.png" );
var spriteMap4 = new textureLoader.load( "assets/obj/tree4.png" );
var spriteMap5 = new textureLoader.load( "assets/obj/bush.png" );
var spriteMap6 = new textureLoader.load( "assets/obj/rock.png" );
var spriteMap7 = new textureLoader.load( "assets/obj/rock2.png" );
var spriteMap8 = new textureLoader.load( "assets/obj/tree5.png" );
var spriteMap9 = new textureLoader.load( "assets/obj/trunk.png" );
var spriteMaterial = new THREE.SpriteMaterial( { map: spriteMap, color: 0xffffff } );
var spriteMaterial2 = new THREE.SpriteMaterial( { map: spriteMap2, color: 0xffffff } );
var spriteMaterial3 = new THREE.SpriteMaterial( { map: spriteMap3, color: 0xffffff } );
var spriteMaterial4 = new THREE.SpriteMaterial( { map: spriteMap4, color: 0xffffff } );
var spriteMaterial5 = new THREE.SpriteMaterial( { map: spriteMap5, color: 0xffffff } );
var spriteMaterial6 = new THREE.SpriteMaterial( { map: spriteMap6, color: 0xffffff } );
var spriteMaterial7 = new THREE.SpriteMaterial( { map: spriteMap7, color: 0xffffff } );
var spriteMaterial8 = new THREE.SpriteMaterial( { map: spriteMap8, color: 0xffffff } );
var spriteMaterial9 = new THREE.SpriteMaterial( { map: spriteMap9, color: 0xffffff } );
var sprite = new THREE.Sprite( spriteMaterial );
var sprite2 = new THREE.Sprite( spriteMaterial2 );
var sprite3 = new THREE.Sprite( spriteMaterial3 );
var sprite4 = new THREE.Sprite( spriteMaterial4 );
var sprite5 = new THREE.Sprite( spriteMaterial5 );
var sprite6 = new THREE.Sprite( spriteMaterial6 );
var sprite7 = new THREE.Sprite( spriteMaterial7 );
var sprite8 = new THREE.Sprite( spriteMaterial8 );
var sprite9 = new THREE.Sprite( spriteMaterial9 );


sprite.scale.set(1,1,1)
sprite.position.y += 0.5
sprite.position.x += 1.25
scene.add( sprite );


sprite2.scale.set(1,1,1)
sprite2.position.y += 0.5
sprite2.position.z += 1.25
scene.add( sprite2 );

sprite3.scale.set(1.5,1.5,1.5)
sprite3.position.y += 0.75
scene.add( sprite3 );


sprite4.scale.set(1,1,1)
sprite4.position.y += 0.5
sprite4.position.x -= 1.25
sprite4.position.z += 1.25
scene.add( sprite4 );

sprite5.scale.set(0.5,0.5,.5)
sprite5.position.y += 0.25
sprite5.position.z -= 1.25
scene.add( sprite5 );

sprite6.scale.set(1,1,1)
sprite6.position.y += .5
sprite6.position.x -= 1.25
scene.add( sprite6 );


sprite7.scale.set(1,1,1)
sprite7.position.y += .5
sprite7.position.x -= 1.25
sprite7.position.z -= 1.25
scene.add( sprite7 );

sprite8.scale.set(0.5,0.5,.5)
sprite8.position.y += 0.25
sprite8.position.x += 1.25
sprite8.position.z -= 1.25
scene.add( sprite8 );

sprite9.scale.set(0.75,0.75,0.75)
sprite9.position.y += 0.375
sprite9.position.x += 1.25
sprite9.position.z += 1.25
scene.add( sprite9 );



var maxAnisotropy = renderer.capabilities.getMaxAnisotropy();

// var texture1 = textureLoader.load( "assets/crate.gif" );
var texture1 = textureLoader.load( "assets/tile2.png" );
// var texture1 = textureLoader.load( "assets/Green_grass_ground_land_dirt_aerial_top_seamless_texture.jpg" );
// var texture1 = textureLoader.load( "assets/grass.jpg" );
var material1 = new THREE.MeshBasicMaterial( { color: 0xffffff, map: texture1 } );

texture1.anisotropy = maxAnisotropy;
texture1.wrapS = texture1.wrapT = THREE.RepeatWrapping;
texture1.repeat.set( 512, 512 );




geometry = new THREE.PlaneBufferGeometry( 100, 100 );

var mesh1 = new THREE.Mesh( geometry, material1 );
mesh1.rotation.x = - Math.PI / 2;
mesh1.scale.set(200,200,200 );
scene.add( mesh1 );


        // scene.add(new THREE.GridHelper(50, 100, 0xaaaaaa, 0x999999))
// scene.add(new THREE.AxesHelper(10))




    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    // pure
    function polarToCartesian(angleV, angleH, radius) {
        var phi = ((90 - angleV) * Math.PI) / 180
        var theta = ((angleH + 180) * Math.PI) / 180
        return {
            x: -radius * Math.sin(phi) * Math.sin(theta),
            y: radius * Math.cos(phi),
            z: -radius * Math.sin(phi) * Math.cos(theta)
        }
    }
    function getScaleFromRadius(camera_radius_position) {
        var half_fov = fov / 2
        var half_fov_radians = (half_fov * Math.PI) / 180
        var half_fov_height = Math.tan(half_fov_radians) * camera_radius_position
        var fov_height = half_fov_height * 2
        var scale = height / fov_height // Divide visualization height by height derived from field of view
        return scale
    }
    function getRadiusFromScale(scale) {
        var half_fov = fov / 2
        var half_fov_radians = (half_fov * Math.PI) / 180
        var scale_height = height / scale
        var camera_radius_position = scale_height / (2 * Math.tan(half_fov_radians))
        return camera_radius_position
    }
    function panCamera(position, lookAt, x, y) {
        var worldUp = new THREE.Vector3(0, 1, 0).normalize()
        var distance = lookAt
            .clone()
            .sub(position)
            .normalize()
        var right = distance
            .clone()
            .cross(worldUp)
            .normalize()
        var up = distance.clone().cross(right)
        right.multiplyScalar(-x)
        up.multiplyScalar(-y)
        position = position
            .clone()
            .add(right)
            .add(up)
        lookAt = lookAt
            .clone()
            .add(right)
            .add(up)
        return {
            position: position,
            lookAt: lookAt
        }
    }

    function updateCameraPosition(d3_transform) {
        var scale = d3_transform.k
        var newRadius = getRadiusFromScale(scale)
        var cameraAngle = polarToCartesian(angleV, angleH, newRadius)
        var x = (d3_transform.x - width / 2) / scale
        var y = (d3_transform.y - height / 2) / scale
        var cameraPaned = panCamera(
            new THREE.Vector3(cameraAngle.x, cameraAngle.y, cameraAngle.z),
            new THREE.Vector3(0, 0, 0),
            x,
            y
        )
        var position = cameraPaned.position
        camera.position.set(position.x, position.y, position.z)
        camera.lookAt(cameraPaned.lookAt)
    }
    
    </script>
</html>